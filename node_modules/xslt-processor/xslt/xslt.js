"use strict";
// Copyright 2023 Design Liquido
// Copyright 2018 Johannes Wilm
// Copyright 2005 Google Inc.
// All Rights Reserved
//
// TODO(mesch): add jsdoc comments. Use more coherent naming. Finish
// remaining XSLT features.
//
// Original author: Steffen Meschkat <mesch@google.com>
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xslt = void 0;
var dom_1 = require("../dom");
var xpath_1 = require("../xpath");
var constants_1 = require("../constants");
var values_1 = require("../xpath/values");
var match_resolver_1 = require("../xpath/match-resolver");
/**
 * The main class for XSL-T processing. The implementation is NOT
 * complete; some xsl element are left out.
 *
 * References:
 *
 * [XSLT] XSL-T Specification
 * <http://www.w3.org/TR/1999/REC-xslt-19991116>.
 *
 * [ECMA] ECMAScript Language Specification
 * <http://www.ecma-international.org/publications/standards/Ecma-262.htm>.
 *
 * The XSL processor API has one entry point, the function
 * xsltProcessContext(). It receives as arguments the starting point in the
 * input document as an XPath expression context, the DOM root node of
 * the XSL-T stylesheet, and a DOM node that receives the output.
 *
 * NOTE: Actually, XSL-T processing according to the specification is
 * defined as operation on text documents, not as operation on DOM
 * trees. So, strictly speaking, this implementation is not an XSL-T
 * processor, but the processing engine that needs to be complemented
 * by an XML parser and serializer in order to be complete. Those two
 * are found in the `dom` folder.
 */
var Xslt = /** @class */ (function () {
    function Xslt(options) {
        if (options === void 0) { options = {
            escape: true,
            selfClosingTags: true,
            parameters: []
        }; }
        this.xPath = new xpath_1.XPath();
        this.matchResolver = new match_resolver_1.MatchResolver();
        this.options = {
            escape: options.escape === true,
            selfClosingTags: options.selfClosingTags === true,
            parameters: options.parameters || []
        };
        this.outputMethod = 'xml';
        this.outputOmitXmlDeclaration = 'no';
        this.decimalFormatSettings = {
            decimalSeparator: '.',
            groupingSeparator: ',',
            infinity: 'Infinity',
            minusSign: '-',
            naN: 'NaN',
            percent: '%',
            perMille: 'â€°',
            zeroDigit: '0',
            digit: '#',
            patternSeparator: ';'
        };
    }
    /**
     * The exported entry point of the XSL-T processor.
     * @param xmlDoc The input document root, as DOM node.
     * @param stylesheet The stylesheet document root, as DOM node.
     * @returns the processed document, as XML text in a string.
     */
    Xslt.prototype.xsltProcess = function (xmlDoc, stylesheet) {
        var outputDocument = new dom_1.XDocument();
        this.outputDocument = outputDocument;
        var expressionContext = new xpath_1.ExprContext([xmlDoc], [outputDocument]);
        if (this.options.parameters.length > 0) {
            for (var _i = 0, _a = this.options.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                expressionContext.setVariable(parameter.name, new values_1.StringValue(parameter.value));
            }
        }
        this.xsltProcessContext(expressionContext, stylesheet);
        var transformedOutputXml = (0, dom_1.xmlTransformedText)(outputDocument, {
            cData: false,
            escape: this.options.escape,
            selfClosingTags: this.options.selfClosingTags,
            outputMethod: this.outputMethod
        });
        return transformedOutputXml;
    };
    /**
     * The main entry point of the XSL-T processor, as explained on the top of the file.
     * @param context The input document root, as XPath `ExprContext`.
     * @param template The stylesheet document root, as DOM node.
     * @param output If set, the output where the transformation should occur.
     */
    Xslt.prototype.xsltProcessContext = function (context, template, output) {
        var _this = this;
        if (!this.isXsltElement(template)) {
            this.xsltPassThrough(context, template, output);
        }
        else {
            var name_1, top_1, nameExpr = void 0, node = void 0, select = void 0, value = void 0, nodes = void 0, mode = void 0, templates = void 0, paramContext = void 0, commentData = void 0, commentNode = void 0, test_1, match = void 0, text = void 0;
            switch (template.localName) {
                case 'apply-imports':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'apply-templates':
                    select = (0, dom_1.xmlGetAttribute)(template, 'select');
                    if (select) {
                        nodes = this.xPath.xPathEval(select, context).nodeSetValue();
                    }
                    else {
                        nodes = context.nodeList[context.position].childNodes;
                    }
                    // TODO: Check why apply-templates was sorting and filing parameters
                    // automatically.
                    /* this.xsltWithParam(sortContext, template);
                    this.xsltSort(sortContext, template); */
                    mode = (0, dom_1.xmlGetAttribute)(template, 'mode');
                    top_1 = template.ownerDocument.documentElement;
                    templates = [];
                    for (var _i = 0, _a = top_1.childNodes.filter(function (c) { return c.nodeType == constants_1.DOM_ELEMENT_NODE && _this.isXsltElement(c, 'template'); }); _i < _a.length; _i++) {
                        var element = _a[_i];
                        // Actual template should be executed.
                        // `<xsl:apply-templates>` should have an ancestor `<xsl:template>`
                        // for comparison.
                        var templateAncestor = template.getAncestorByLocalName('template');
                        if (templateAncestor === undefined) {
                            continue;
                        }
                        if (templateAncestor.id === element.id) {
                            continue;
                        }
                        if (!mode || element.getAttributeValue('mode') === mode) {
                            templates.push(element);
                        }
                    }
                    var modifiedContext = context.clone(nodes);
                    for (var i = 0; i < templates.length; ++i) {
                        for (var j = 0; j < modifiedContext.contextSize(); ++j) {
                            // If the current node is text, there's no need to test all the templates
                            // against it. Just appending it to its parent is fine.
                            if (modifiedContext.nodeList[j].nodeType === constants_1.DOM_TEXT_NODE) {
                                var textNodeContext = context.clone([modifiedContext.nodeList[j]], undefined, 0, undefined);
                                // TODO: verify if it is okay to pass the own text node as template.
                                this.commonLogicTextNode(textNodeContext, modifiedContext.nodeList[j]);
                            }
                            else {
                                var clonedContext_1 = modifiedContext.clone([modifiedContext.nodeList[j]], undefined, 
                                // [modifiedContext.nodeList[j].outputNode],
                                0, undefined
                                // 0
                                );
                                clonedContext_1.inApplyTemplates = true;
                                // The output depth should be restarted, since
                                // another template is being applied from this point.
                                clonedContext_1.outputDepth = 0;
                                this.xsltProcessContext(clonedContext_1, templates[i], output);
                            }
                        }
                    }
                    break;
                case 'attribute':
                    nameExpr = (0, dom_1.xmlGetAttribute)(template, 'name');
                    name_1 = this.xsltAttributeValue(nameExpr, context);
                    var documentFragment = (0, dom_1.domCreateDocumentFragment)(this.outputDocument);
                    this.xsltChildNodes(context, template, documentFragment);
                    value = (0, dom_1.xmlValue2)(documentFragment);
                    if (output !== null && output !== undefined) {
                        (0, dom_1.domSetTransformedAttribute)(output, name_1, value);
                    }
                    else {
                        var sourceNode = context.nodeList[context.position];
                        var parentSourceNode = sourceNode.parentNode;
                        var outputNode = sourceNode.outputNode;
                        // At this point, the output node should exist.
                        // If not, a new node is created.
                        if (outputNode === null || outputNode === undefined) {
                            outputNode = new dom_1.XNode(sourceNode.nodeType, sourceNode.nodeName, sourceNode.nodeValue, context.outputNodeList[context.outputPosition], sourceNode.namespaceUri);
                            sourceNode.outputNode = outputNode;
                        }
                        // Corner case:
                        // It can happen here that we don't have the root node set.
                        // In this case we need to append a copy of the root
                        // source node to receive the attribute.
                        if (outputNode.localName === "#document") {
                            var sourceRootNode = context.root.childNodes[0];
                            var newRootNode = (0, dom_1.domCreateElement)(this.outputDocument, sourceRootNode.nodeName);
                            newRootNode.transformedNodeName = sourceRootNode.nodeName;
                            newRootNode.transformedLocalName = sourceRootNode.localName;
                            (0, dom_1.domAppendTransformedChild)(outputNode, newRootNode);
                            outputNode = newRootNode;
                            parentSourceNode = newRootNode;
                        }
                        // Some operations start by the tag attributes, and not by the tag itself.
                        // When this is the case, the output node is not set yet, so
                        // we add the transformed attributes into the original tag.
                        if (parentSourceNode && parentSourceNode.outputNode) {
                            (0, dom_1.domSetTransformedAttribute)(parentSourceNode.outputNode, name_1, value);
                        }
                        else {
                            (0, dom_1.domSetTransformedAttribute)(parentSourceNode, name_1, value);
                        }
                    }
                    break;
                case 'attribute-set':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'call-template':
                    name_1 = (0, dom_1.xmlGetAttribute)(template, 'name');
                    top_1 = template.ownerDocument.documentElement;
                    paramContext = context.clone();
                    this.xsltWithParam(paramContext, template);
                    for (var i = 0; i < top_1.childNodes.length; ++i) {
                        var c = top_1.childNodes[i];
                        if (c.nodeType == constants_1.DOM_ELEMENT_NODE &&
                            this.isXsltElement(c, 'template') &&
                            (0, dom_1.domGetAttributeValue)(c, 'name') == name_1) {
                            this.xsltChildNodes(paramContext, c, output);
                            break;
                        }
                    }
                    break;
                case 'choose':
                    this.xsltChoose(context, template, output);
                    break;
                case 'comment':
                    node = (0, dom_1.domCreateDocumentFragment)(this.outputDocument);
                    this.xsltChildNodes(context, template, node);
                    commentData = (0, dom_1.xmlValue)(node);
                    commentNode = (0, dom_1.domCreateComment)(this.outputDocument, commentData);
                    output.appendChild(commentNode);
                    break;
                case 'copy':
                    var destinationCopyNode = output || context.outputNodeList[context.outputPosition];
                    node = this.xsltCopy(destinationCopyNode, context.nodeList[context.position]);
                    if (node) {
                        this.xsltChildNodes(context, template, node);
                    }
                    break;
                case 'copy-of':
                    select = (0, dom_1.xmlGetAttribute)(template, 'select');
                    value = this.xPath.xPathEval(select, context);
                    var destinationNode = output || context.outputNodeList[context.outputPosition];
                    if (value.type === 'node-set') {
                        nodes = value.nodeSetValue();
                        for (var i = 0; i < nodes.length; ++i) {
                            this.xsltCopyOf(destinationNode, nodes[i]);
                        }
                    }
                    else {
                        var node_1 = (0, dom_1.domCreateTextNode)(this.outputDocument, value.stringValue());
                        (0, dom_1.domAppendChild)(destinationNode, node_1);
                    }
                    break;
                case 'decimal-format':
                    name_1 = (0, dom_1.xmlGetAttribute)(template, 'name');
                    var decimalSeparator = (0, dom_1.xmlGetAttribute)(template, 'decimal-separator');
                    var groupingSeparator = (0, dom_1.xmlGetAttribute)(template, 'grouping-separator');
                    var infinity = (0, dom_1.xmlGetAttribute)(template, 'infinity');
                    var minusSign = (0, dom_1.xmlGetAttribute)(template, 'minus-sign');
                    var naN = (0, dom_1.xmlGetAttribute)(template, 'NaN');
                    var percent = (0, dom_1.xmlGetAttribute)(template, 'percent');
                    var perMille = (0, dom_1.xmlGetAttribute)(template, 'per-mille');
                    var zeroDigit = (0, dom_1.xmlGetAttribute)(template, 'zero-digit');
                    var digit = (0, dom_1.xmlGetAttribute)(template, 'digit');
                    var patternSeparator = (0, dom_1.xmlGetAttribute)(template, 'pattern-separator');
                    this.decimalFormatSettings = {
                        name: name_1 || this.decimalFormatSettings.name,
                        decimalSeparator: decimalSeparator || this.decimalFormatSettings.decimalSeparator,
                        groupingSeparator: groupingSeparator || this.decimalFormatSettings.groupingSeparator,
                        infinity: infinity || this.decimalFormatSettings.infinity,
                        minusSign: minusSign || this.decimalFormatSettings.minusSign,
                        naN: naN || this.decimalFormatSettings.naN,
                        percent: percent || this.decimalFormatSettings.percent,
                        perMille: perMille || this.decimalFormatSettings.perMille,
                        zeroDigit: zeroDigit || this.decimalFormatSettings.zeroDigit,
                        digit: digit || this.decimalFormatSettings.digit,
                        patternSeparator: patternSeparator || this.decimalFormatSettings.patternSeparator
                    };
                    context.decimalFormatSettings = this.decimalFormatSettings;
                    break;
                case 'element':
                    nameExpr = (0, dom_1.xmlGetAttribute)(template, 'name');
                    name_1 = this.xsltAttributeValue(nameExpr, context);
                    node = (0, dom_1.domCreateElement)(this.outputDocument, name_1);
                    node.transformedNodeName = name_1;
                    (0, dom_1.domAppendTransformedChild)(context.outputNodeList[context.outputPosition], node);
                    var clonedContext = context.clone(undefined, [node], undefined, 0);
                    this.xsltChildNodes(clonedContext, template, node);
                    break;
                case 'fallback':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'for-each':
                    this.xsltForEach(context, template, output);
                    break;
                case 'if':
                    test_1 = (0, dom_1.xmlGetAttribute)(template, 'test');
                    if (this.xPath.xPathEval(test_1, context).booleanValue()) {
                        this.xsltChildNodes(context, template, output);
                    }
                    break;
                case 'import':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'include':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'key':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'message':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'namespace-alias':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'number':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'otherwise':
                    throw "error if here: ".concat(template.localName);
                case 'output':
                    this.outputMethod = (0, dom_1.xmlGetAttribute)(template, 'method');
                    this.outputOmitXmlDeclaration = (0, dom_1.xmlGetAttribute)(template, 'omit-xml-declaration');
                    break;
                case 'param':
                    this.xsltVariable(context, template, false);
                    break;
                case 'preserve-space':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'processing-instruction':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'sort':
                    this.xsltSort(context, template);
                    break;
                case 'strip-space':
                    throw new Error("not implemented: ".concat(template.localName));
                case 'stylesheet':
                case 'transform':
                    this.xsltTransformOrStylesheet(template, context, output);
                    break;
                case 'template':
                    // If `<xsl:template>` is executed outside `<xsl:apply-templates>`,
                    // only one match is accepted per level (or per context here).
                    if (!context.inApplyTemplates && context.baseTemplateMatched) {
                        break;
                    }
                    match = (0, dom_1.xmlGetAttribute)(template, 'match');
                    if (!match)
                        break;
                    // XPath doesn't have an axis to select "self and siblings", and
                    // the default axis is "child", so to select the correct children
                    // in relative path, we force a 'self-and-siblings' axis.
                    nodes = this.xsltMatch(match, context, 'self-and-siblings');
                    if (nodes.length > 0) {
                        if (!context.inApplyTemplates) {
                            context.baseTemplateMatched = true;
                        }
                        var templateContext = context.clone(nodes, undefined, 0);
                        this.xsltChildNodes(templateContext, template, output);
                    }
                    break;
                case 'text':
                    text = (0, dom_1.xmlValue)(template);
                    node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, text);
                    var disableOutputEscaping = template.attributes.filter(function (a) { return a.nodeName === 'disable-output-escaping'; });
                    if (disableOutputEscaping.length > 0 && disableOutputEscaping[0].nodeValue === 'yes') {
                        node.escape = false;
                    }
                    var destinationTextNode = output || context.outputNodeList[context.outputPosition];
                    destinationTextNode.appendTransformedChild(node);
                    break;
                case 'value-of':
                    select = (0, dom_1.xmlGetAttribute)(template, 'select');
                    var attribute = this.xPath.xPathEval(select, context);
                    value = attribute.stringValue();
                    node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, value);
                    node.siblingPosition = context.nodeList[context.position].siblingPosition;
                    if (output !== null && output !== undefined) {
                        output.appendTransformedChild(node);
                    }
                    else {
                        context.outputNodeList[context.outputPosition].appendTransformedChild(node);
                    }
                    break;
                case 'variable':
                    this.xsltVariable(context, template, true);
                    break;
                case 'when':
                    throw new Error("error if here: ".concat(template.localName));
                case 'with-param':
                    throw new Error("error if here: ".concat(template.localName));
                default:
                    throw new Error("error if here: ".concat(template.localName));
            }
        }
    };
    /**
     * Implements xsl:choose and its child nodes xsl:when and
     * xsl:otherwise.
     * @param input The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltChoose = function (input, template, output) {
        for (var _i = 0, _a = template.childNodes; _i < _a.length; _i++) {
            var childNode = _a[_i];
            if (childNode.nodeType !== constants_1.DOM_ELEMENT_NODE) {
                continue;
            }
            if (this.isXsltElement(childNode, 'when')) {
                var test_2 = (0, dom_1.xmlGetAttribute)(childNode, 'test');
                if (this.xPath.xPathEval(test_2, input).booleanValue()) {
                    this.xsltChildNodes(input, childNode, output);
                    break;
                }
            }
            else if (this.isXsltElement(childNode, 'otherwise')) {
                this.xsltChildNodes(input, childNode, output);
                break;
            }
        }
    };
    /**
     * Implements `xsl:copy` for all node types.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     * @returns {XNode|null} If an element node was created, the element node. Otherwise, null.
     */
    Xslt.prototype.xsltCopy = function (destination, source) {
        if (source.nodeType == constants_1.DOM_ELEMENT_NODE) {
            var node = (0, dom_1.domCreateElement)(this.outputDocument, source.nodeName);
            node.transformedNodeName = source.nodeName;
            if (source.namespaceUri !== null && source.namespaceUri !== undefined) {
                (0, dom_1.domSetTransformedAttribute)(node, 'xmlns', source.namespaceUri);
            }
            (0, dom_1.domAppendTransformedChild)(destination, node);
            return node;
        }
        if (source.nodeType == constants_1.DOM_TEXT_NODE) {
            var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_CDATA_SECTION_NODE) {
            var node = (0, dom_1.domCreateCDATASection)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_COMMENT_NODE) {
            var node = (0, dom_1.domCreateComment)(this.outputDocument, source.nodeValue);
            (0, dom_1.domAppendTransformedChild)(destination, node);
        }
        else if (source.nodeType == constants_1.DOM_ATTRIBUTE_NODE) {
            (0, dom_1.domSetTransformedAttribute)(destination, source.nodeName, source.nodeValue);
        }
        return null;
    };
    /**
     * Implements `xsl:copy-of` for node-set values of the select
     * expression. Recurses down the source node tree, which is part of
     * the input document.
     * @param {XNode} destination the node being copied to, part of output document.
     * @param {XNode} source the node being copied, part in input document.
     */
    Xslt.prototype.xsltCopyOf = function (destination, source) {
        if (source.nodeType == constants_1.DOM_DOCUMENT_FRAGMENT_NODE || source.nodeType == constants_1.DOM_DOCUMENT_NODE) {
            for (var i = 0; i < source.childNodes.length; ++i) {
                this.xsltCopyOf(destination, source.childNodes[i]);
            }
        }
        else {
            var node = this.xsltCopy(destination, source);
            if (node) {
                // This was an element node -- recurse to attributes and
                // children.
                for (var i = 0; i < source.attributes.length; ++i) {
                    this.xsltCopyOf(node, source.attributes[i]);
                }
                for (var i = 0; i < source.childNodes.length; ++i) {
                    this.xsltCopyOf(node, source.childNodes[i]);
                }
            }
        }
    };
    /**
     * Implements `xsl:for-each`.
     * @param input The Expression Context.
     * @param template The template.
     * @param output The output.
     */
    Xslt.prototype.xsltForEach = function (context, template, output) {
        var select = (0, dom_1.xmlGetAttribute)(template, 'select');
        var nodes = this.xPath.xPathEval(select, context).nodeSetValue();
        if (nodes.length === 0) {
            return;
        }
        var sortContext = context.clone(nodes);
        this.xsltSort(sortContext, template);
        var nodesWithParent = sortContext.nodeList.filter(function (n) { return n.parentNode !== null && n.parentNode !== undefined; });
        if (nodesWithParent.length <= 0) {
            throw new Error('Nodes with no parents defined.');
        }
        var parent = nodesWithParent[0].parentNode;
        parent.childNodes = sortContext.nodeList;
        for (var i = 0; i < sortContext.contextSize(); ++i) {
            this.xsltChildNodes(sortContext.clone(sortContext.nodeList, undefined, i), template, output);
        }
    };
    /**
     * Orders the current node list in the input context according to the
     * sort order specified by xsl:sort child nodes of the current
     * template node. This happens before the operation specified by the
     * current template node is executed.
     * @param context The expression context.
     * @param template The template node.
     * @todo case-order is not implemented.
     */
    Xslt.prototype.xsltSort = function (context, template) {
        var sort = [];
        for (var _i = 0, _a = template.childNodes; _i < _a.length; _i++) {
            var childNode = _a[_i];
            if (childNode.nodeType == constants_1.DOM_ELEMENT_NODE && this.isXsltElement(childNode, 'sort')) {
                var select = (0, dom_1.xmlGetAttribute)(childNode, 'select');
                var expression = this.xPath.xPathParse(select);
                var type = (0, dom_1.xmlGetAttribute)(childNode, 'data-type') || 'text';
                var order = (0, dom_1.xmlGetAttribute)(childNode, 'order') || 'ascending';
                sort.push({
                    expr: expression,
                    type: type,
                    order: order
                });
            }
        }
        this.xPath.xPathSort(context, sort);
    };
    /**
     * Implements `<xsl:stylesheet>` and `<xsl:transform>`, and its corresponding
     * validations.
     * @param template The `<xsl:stylesheet>` or `<xsl:transform>` node.
     * @param context The Expression Context.
     * @param output The output XML.
     */
    Xslt.prototype.xsltTransformOrStylesheet = function (template, context, output) {
        for (var _i = 0, _a = template.attributes; _i < _a.length; _i++) {
            var stylesheetAttribute = _a[_i];
            switch (stylesheetAttribute.nodeName) {
                case 'version':
                    this.version = stylesheetAttribute.nodeValue;
                    if (!['1.0', '2.0', '3.0'].includes(this.version)) {
                        throw new Error("XSLT version not defined or invalid. Actual resolved version: ".concat(this.version || '(none)', "."));
                    }
                    context.xsltVersion = this.version;
                    break;
                default:
                    if (stylesheetAttribute.prefix === 'xmlns') {
                        context.knownNamespaces[stylesheetAttribute.localName] = stylesheetAttribute.nodeValue;
                    }
                    break;
            }
        }
        this.xsltChildNodes(context, template, output);
    };
    /**
     * Evaluates a variable or parameter and set it in the current input
     * context. Implements `xsl:variable`, `xsl:param`, and `xsl:with-param`.
     *
     * @param input TODO
     * @param template TODO
     * @param override flag that defines if the value computed here
     * overrides the one already in the input context if that is the
     * case. I.e. decides if this is a default value or a local
     * value. `xsl:variable` and `xsl:with-param` override; `xsl:param` doesn't.
     */
    Xslt.prototype.xsltVariable = function (input, template, override) {
        var name = (0, dom_1.xmlGetAttribute)(template, 'name');
        var select = (0, dom_1.xmlGetAttribute)(template, 'select');
        var value;
        if (template.childNodes.length > 0) {
            var root = (0, dom_1.domCreateDocumentFragment)(template.ownerDocument);
            this.xsltChildNodes(input, template, root);
            value = new values_1.NodeSetValue([root]);
        }
        else if (select) {
            value = this.xPath.xPathEval(select, input);
        }
        else {
            var parameterValue = '';
            var filteredParameter = this.options.parameters.filter(function (p) { return p.name === name; });
            if (filteredParameter.length > 0) {
                parameterValue = filteredParameter[0].value;
            }
            value = new values_1.StringValue(parameterValue);
        }
        if (override || !input.getVariable(name)) {
            input.setVariable(name, value);
        }
    };
    /**
     * Traverses the template node tree. Calls the main processing
     * function with the current input context for every child node of the
     * current template node.
     * @param context Normally the Expression Context.
     * @param template The XSL-T definition.
     * @param output If set, the output where the transformation should occur.
     */
    Xslt.prototype.xsltChildNodes = function (context, template, output) {
        // Clone input context to keep variables declared here local to the
        // siblings of the children.
        var contextClone = context.clone();
        for (var i = 0; i < template.childNodes.length; ++i) {
            this.xsltProcessContext(contextClone, template.childNodes[i], output);
        }
    };
    /**
     * This logic is used in two different places:
     * - `xsltPassThrough`, if the template asks this library to write a text node;
     * - `xsltProcessContext`, `apply-templates` operation, when the current node is text.
     * @param context The Expression Context.
     * @param template The template, that contains the node value to be written.
     */
    Xslt.prototype.commonLogicTextNode = function (context, template) {
        var textNodeList = context.outputNodeList[context.outputPosition].transformedChildNodes.filter(function (n) { return n.nodeType === constants_1.DOM_TEXT_NODE; });
        if (textNodeList.length > 0) {
            var node = textNodeList[0];
            node.transformedNodeValue = template.nodeValue;
        }
        else {
            var node = (0, dom_1.domCreateTransformedTextNode)(this.outputDocument, template.nodeValue);
            node.transformedParentNode = context.outputNodeList[context.outputPosition];
            (0, dom_1.domAppendTransformedChild)(context.outputNodeList[context.outputPosition], node);
        }
    };
    /**
     * Passes template text to the output. The current template node does
     * not specify an XSL-T operation and therefore is appended to the
     * output with all its attributes. Then continues traversing the
     * template node tree.
     * @param context The Expression Context.
     * @param template The XSLT stylesheet or transformation.
     * @param output The output.
     */
    Xslt.prototype.xsltPassThrough = function (context, template, output) {
        if (template.nodeType == constants_1.DOM_TEXT_NODE) {
            if (this.xsltPassText(template)) {
                this.commonLogicTextNode(context, template);
            }
        }
        else if (template.nodeType == constants_1.DOM_ELEMENT_NODE) {
            var node = void 0;
            var elementContext = context;
            if (context.nodeList[context.position].nodeName === '#document') {
                node = context.nodeList[context.position].childNodes.find(function (c) { return c.nodeName !== '#dtd-section'; });
                elementContext = context.clone([node]);
            }
            else {
                node = context.nodeList[context.position];
            }
            var newNode = void 0;
            if (node.outputNode === undefined || node.outputNode === null || context.outputDepth > 0) {
                newNode = (0, dom_1.domCreateElement)(this.outputDocument, template.nodeName);
                newNode.siblingPosition = node.siblingPosition;
                if (context.outputDepth === 0) {
                    node.outputNode = newNode;
                }
            }
            else {
                newNode = node.outputNode;
            }
            newNode.transformedNodeName = template.nodeName;
            newNode.transformedLocalName = template.localName;
            // The node can have transformed attributes from previous transformations.
            for (var _i = 0, _a = node.transformedAttributes; _i < _a.length; _i++) {
                var previouslyTransformedAttribute = _a[_i];
                var name_2 = previouslyTransformedAttribute.transformedNodeName;
                var value = previouslyTransformedAttribute.transformedNodeValue;
                (0, dom_1.domSetTransformedAttribute)(newNode, name_2, value);
            }
            var templateAttributes = template.attributes.filter(function (a) { return a; });
            for (var _b = 0, templateAttributes_1 = templateAttributes; _b < templateAttributes_1.length; _b++) {
                var attribute = templateAttributes_1[_b];
                var name_3 = attribute.nodeName;
                var value = this.xsltAttributeValue(attribute.nodeValue, elementContext);
                (0, dom_1.domSetTransformedAttribute)(newNode, name_3, value);
            }
            var outputNode = context.outputNodeList[context.outputPosition];
            (0, dom_1.domAppendTransformedChild)(outputNode, newNode);
            var clonedContext = elementContext.cloneByOutput(outputNode.transformedChildNodes, outputNode.transformedChildNodes.length - 1, ++elementContext.outputDepth);
            this.xsltChildNodes(clonedContext, template);
        }
        else {
            // This applies also to the DOCUMENT_NODE of the XSL stylesheet,
            // so we don't have to treat it specially.
            this.xsltChildNodes(context, template, output);
        }
    };
    /**
     * Determines if a text node in the XSLT template document is to be
     * stripped according to XSLT whitespace stripping rules.
     * @see [XSLT], section 3.4.
     * @param template The XSLT template.
     * @returns TODO
     * @todo Whitespace stripping on the input document is
     * currently not implemented.
     */
    Xslt.prototype.xsltPassText = function (template) {
        if (!template.nodeValue.match(/^\s*$/)) {
            return true;
        }
        var element = template.parentNode;
        if (this.isXsltElement(element, 'text')) {
            return true;
        }
        while (element && element.nodeType == constants_1.DOM_ELEMENT_NODE) {
            var xmlspace = (0, dom_1.domGetAttributeValue)(element, 'xml:space');
            if (xmlspace) {
                if (xmlspace == 'default') {
                    return false;
                }
                if (xmlspace == 'preserve') {
                    return true;
                }
            }
            element = element.parentNode;
        }
        return false;
    };
    Xslt.prototype.xsltAttribute = function (attributeName, context) {
        return context.nodeList[context.position].attributes.find(function (a) { return a.nodeName === attributeName; });
    };
    /**
     * Evaluates an XSL-T attribute value template. Attribute value
     * templates are attributes on XSL-T elements that contain XPath
     * expressions in braces {}. The XSL-T expressions are evaluated in
     * the current input context.
     * @param value TODO
     * @param context TODO
     * @returns TODO
     */
    Xslt.prototype.xsltAttributeValue = function (value, context) {
        var parts = value.split('{');
        if (parts.length === 1) {
            return value;
        }
        var ret = '';
        for (var i = 0; i < parts.length; ++i) {
            var rp = parts[i].split('}');
            if (rp.length != 2) {
                // first literal part of the value
                ret += parts[i];
                continue;
            }
            var val = this.xPath.xPathEval(rp[0], context).stringValue();
            ret += val + rp[1];
        }
        return ret;
    };
    /**
     * Evaluates an XPath expression in the current input context as a
     * match.
     * @see [XSLT] section 5.2, paragraph 1
     * @param match TODO
     * @param context The Expression Context.
     * @param axis The XPath axis. Used when the match does not start with the parent.
     * @returns {XNode[]} A list of the found nodes.
     */
    Xslt.prototype.xsltMatch = function (match, context, axis) {
        var expression = this.xPath.xPathParse(match, axis);
        return this.matchResolver.expressionMatch(expression, context);
    };
    /**
     * Sets parameters defined by xsl:with-param child nodes of the
     * current template node, in the current input context. This happens
     * before the operation specified by the current template node is
     * executed.
     * @param input TODO
     * @param template TODO
     */
    Xslt.prototype.xsltWithParam = function (input, template) {
        for (var _i = 0, _a = template.childNodes; _i < _a.length; _i++) {
            var c = _a[_i];
            if (c.nodeType === constants_1.DOM_ELEMENT_NODE && this.isXsltElement(c, 'with-param')) {
                this.xsltVariable(input, c, true);
            }
        }
    };
    // Test if the given element is an XSLT element, optionally the one with the given name
    Xslt.prototype.isXsltElement = function (element, opt_wantedName) {
        if (opt_wantedName && element.localName != opt_wantedName)
            return false;
        if (element.namespaceUri)
            return element.namespaceUri === 'http://www.w3.org/1999/XSL/Transform';
        return element.prefix === 'xsl'; // backwards compatibility with earlier versions of xslt-processor
    };
    return Xslt;
}());
exports.Xslt = Xslt;
//# sourceMappingURL=xslt.js.map