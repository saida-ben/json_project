"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xmlOwnerDocument = exports.xmlGetAttribute = exports.xmlEscapeText = exports.xmlTransformedText = exports.xmlText = exports.xmlValue2 = exports.xmlValue = void 0;
var he_1 = __importDefault(require("he"));
var constants_1 = require("../constants");
var functions_1 = require("./functions");
/**
 * Returns the text value of a node; for nodes without children this
 * is the nodeValue, for nodes with children this is the concatenation
 * of the value of all children. Browser-specific optimizations are used by
 * default; they can be disabled by passing "true" in as the second parameter.
 * @param node The Node (not exactly a `XNode` here).
 * @param disallowBrowserSpecificOptimization A boolean, to avoid browser optimization.
 * @returns The XML value as a string.
 */
function xmlValue(node, disallowBrowserSpecificOptimization) {
    if (disallowBrowserSpecificOptimization === void 0) { disallowBrowserSpecificOptimization = false; }
    if (!node) {
        return '';
    }
    var ret = '';
    switch (node.nodeType) {
        case constants_1.DOM_DOCUMENT_TYPE_NODE:
            return "<!DOCTYPE ".concat(node.nodeValue, ">");
        case constants_1.DOM_TEXT_NODE:
        case constants_1.DOM_CDATA_SECTION_NODE:
        case constants_1.DOM_ATTRIBUTE_NODE:
            return node.nodeValue;
        case constants_1.DOM_ELEMENT_NODE:
        case constants_1.DOM_DOCUMENT_NODE:
        case constants_1.DOM_DOCUMENT_FRAGMENT_NODE:
            if (!disallowBrowserSpecificOptimization) {
                // IE, Safari, Opera, and friends
                var innerText = node.innerText;
                if (innerText != undefined) {
                    return innerText;
                }
                // Firefox
                var textContent = node.textContent;
                if (textContent != undefined) {
                    return textContent;
                }
            }
            if (node.transformedChildNodes.length > 0) {
                for (var i = 0; i < node.transformedChildNodes.length; ++i) {
                    ret += xmlValue(node.transformedChildNodes[i]);
                }
            }
            else {
                for (var i = 0; i < node.childNodes.length; ++i) {
                    ret += xmlValue(node.childNodes[i]);
                }
            }
            return ret;
    }
}
exports.xmlValue = xmlValue;
// TODO: Give a better name to this.
function xmlValue2(node, disallowBrowserSpecificOptimization) {
    if (disallowBrowserSpecificOptimization === void 0) { disallowBrowserSpecificOptimization = false; }
    if (!node) {
        return '';
    }
    var ret = '';
    if (node.nodeType == constants_1.DOM_TEXT_NODE || node.nodeType == constants_1.DOM_CDATA_SECTION_NODE) {
        ret += node.nodeValue;
    }
    else if (node.nodeType == constants_1.DOM_ATTRIBUTE_NODE) {
        ret += node.nodeValue;
    }
    else if (node.nodeType == constants_1.DOM_ELEMENT_NODE ||
        node.nodeType == constants_1.DOM_DOCUMENT_NODE ||
        node.nodeType == constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
        if (!disallowBrowserSpecificOptimization) {
            // IE, Safari, Opera, and friends
            var innerText = node.innerText;
            if (innerText != undefined) {
                return innerText;
            }
            // Firefox
            var textContent = node.textContent;
            if (textContent != undefined) {
                return textContent;
            }
        }
        // pobrecito!
        var len = node.transformedChildNodes.length;
        for (var i = 0; i < len; ++i) {
            ret += xmlValue(node.transformedChildNodes[i]);
        }
    }
    return ret;
}
exports.xmlValue2 = xmlValue2;
/**
 * Returns the representation of a node as XML text.
 * In general it is not used by XSLT, that uses `xmlTransformedText` instead.
 * @param {XNode} node The starting node.
 * @param {XmlOutputOptions} options XML output options.
 * @returns The XML string.
 * @see xmlTransformedText
 */
function xmlText(node, options) {
    if (options === void 0) { options = {
        cData: false,
        escape: true,
        selfClosingTags: true,
        outputMethod: 'xml'
    }; }
    var buffer = [];
    xmlTextRecursive(node, buffer, options);
    return buffer.join('');
}
exports.xmlText = xmlText;
function xmlTextRecursive(node, buffer, options) {
    if (node.nodeType == constants_1.DOM_TEXT_NODE) {
        buffer.push(xmlEscapeText(node.nodeValue));
    }
    else if (node.nodeType == constants_1.DOM_CDATA_SECTION_NODE) {
        if (options.cData) {
            buffer.push(node.nodeValue);
        }
        else {
            buffer.push("<![CDATA[".concat(node.nodeValue, "]]>"));
        }
    }
    else if (node.nodeType == constants_1.DOM_COMMENT_NODE) {
        buffer.push("<!--".concat(node.nodeValue, "-->"));
    }
    else if (node.nodeType == constants_1.DOM_ELEMENT_NODE) {
        buffer.push("<".concat(xmlFullNodeName(node)));
        for (var i = 0; i < node.attributes.length; ++i) {
            var a = node.attributes[i];
            if (a && a.nodeName && a.nodeValue) {
                buffer.push(" ".concat(xmlFullNodeName(a), "=\"").concat(xmlEscapeAttr(a.nodeValue), "\""));
            }
        }
        if (node.childNodes.length === 0) {
            if (options.selfClosingTags || (options.outputMethod === 'html' && ['hr', 'link'].includes(node.nodeName))) {
                buffer.push('/>');
            }
            else {
                buffer.push("></".concat(xmlFullNodeName(node), ">"));
            }
        }
        else {
            buffer.push('>');
            for (var i = 0; i < node.childNodes.length; ++i) {
                xmlTextRecursive(node.childNodes[i], buffer, options);
            }
            buffer.push("</".concat(xmlFullNodeName(node), ">"));
        }
    }
    else if (node.nodeType == constants_1.DOM_DOCUMENT_NODE || node.nodeType == constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
        for (var i = 0; i < node.childNodes.length; ++i) {
            xmlTextRecursive(node.childNodes[i], buffer, options);
        }
    }
}
/**
 * Returns the representation of a node as XML text.
 * @param {XNode} node The starting node.
 * @param {XmlOutputOptions} options XML output options.
 * @returns The XML string.
 */
function xmlTransformedText(node, options) {
    if (options === void 0) { options = {
        cData: false,
        escape: true,
        selfClosingTags: true,
        outputMethod: 'xml'
    }; }
    var buffer = [];
    xmlTransformedTextRecursive(node, buffer, options);
    return buffer.join('');
}
exports.xmlTransformedText = xmlTransformedText;
function xmlTransformedTextRecursive(node, buffer, options) {
    if (node.visited)
        return;
    var nodeType = node.transformedNodeType || node.nodeType;
    var nodeValue = node.transformedNodeValue || node.nodeValue;
    if (nodeType === constants_1.DOM_TEXT_NODE) {
        if (node.transformedNodeValue && node.transformedNodeValue.trim() !== '') {
            var finalText = node.escape && options.escape ?
                xmlEscapeText(node.transformedNodeValue) :
                node.transformedNodeValue;
            buffer.push(finalText);
        }
    }
    else if (nodeType === constants_1.DOM_CDATA_SECTION_NODE) {
        if (options.cData) {
            buffer.push(nodeValue);
        }
        else {
            buffer.push("<![CDATA[".concat(nodeValue, "]]>"));
        }
    }
    else if (nodeType == constants_1.DOM_COMMENT_NODE) {
        buffer.push("<!-- ".concat(nodeValue, " -->"));
    }
    else if (nodeType == constants_1.DOM_ELEMENT_NODE) {
        // If node didn't have a transformed name, but its children
        // had transformations, children should be present at output.
        // This is called here "muted logic".
        if (node.transformedNodeName !== null && node.transformedNodeName !== undefined) {
            xmlElementLogicTrivial(node, buffer, options);
        }
        else {
            xmlElementLogicMuted(node, buffer, options);
        }
    }
    else if (nodeType === constants_1.DOM_DOCUMENT_NODE || nodeType === constants_1.DOM_DOCUMENT_FRAGMENT_NODE) {
        var childNodes = node.transformedChildNodes.concat(node.childNodes);
        childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
        for (var i = 0; i < childNodes.length; ++i) {
            xmlTransformedTextRecursive(childNodes[i], buffer, options);
        }
    }
    node.visited = true;
}
/**
 * XML element output, trivial logic.
 * @param node The XML node.
 * @param buffer The XML buffer.
 * @param cdata If using CDATA configuration.
 */
function xmlElementLogicTrivial(node, buffer, options) {
    buffer.push("<".concat(xmlFullNodeName(node)));
    var attributes = node.transformedAttributes || node.attributes;
    for (var i = 0; i < attributes.length; ++i) {
        var attribute = attributes[i];
        if (!attribute) {
            continue;
        }
        if (attribute.transformedNodeName && attribute.transformedNodeValue) {
            buffer.push(" ".concat(xmlFullNodeName(attribute), "=\"").concat(xmlEscapeAttr(attribute.transformedNodeValue), "\""));
        }
    }
    var childNodes = node.transformedChildNodes.length > 0 ? node.transformedChildNodes : node.childNodes;
    childNodes = childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
    if (childNodes.length === 0) {
        if (options.outputMethod === 'html' && ['hr', 'link', 'meta'].includes(node.nodeName)) {
            buffer.push('>');
        }
        else if (options.selfClosingTags) {
            buffer.push('/>');
        }
        else {
            buffer.push("></".concat(xmlFullNodeName(node), ">"));
        }
    }
    else {
        buffer.push('>');
        for (var i = 0; i < childNodes.length; ++i) {
            xmlTransformedTextRecursive(childNodes[i], buffer, options);
        }
        buffer.push("</".concat(xmlFullNodeName(node), ">"));
    }
}
/**
 * XML element output, muted logic.
 * In other words, this element should not be printed, but its
 * children can be printed if they have transformed values.
 * @param node The XML node.
 * @param buffer The XML buffer.
 * @param cdata If using CDATA configuration.
 */
function xmlElementLogicMuted(node, buffer, options) {
    var childNodes = node.transformedChildNodes.length > 0 ? node.transformedChildNodes : node.childNodes;
    childNodes = childNodes.sort(function (a, b) { return a.siblingPosition - b.siblingPosition; });
    for (var i = 0; i < childNodes.length; ++i) {
        xmlTransformedTextRecursive(childNodes[i], buffer, options);
    }
}
/**
 * Gets the full node name.
 * When namespace is set, the node name is `namespace:node`.
 * @param node The node.
 * @returns The full node name as a string.
 */
function xmlFullNodeName(node) {
    var nodeName = node.transformedNodeName || node.nodeName;
    if (node.transformedPrefix && nodeName.indexOf("".concat(node.transformedPrefix, ":")) != 0) {
        return "".concat(node.transformedPrefix, ":").concat(nodeName);
    }
    return nodeName;
}
/**
 * Escape XML special markup chracters: tag delimiter < > and entity
 * reference start delimiter &. The escaped string can be used in XML
 * text portions (i.e. between tags).
 * @param s The string to be escaped.
 * @returns The escaped string.
 */
function xmlEscapeText(s) {
    return "".concat(s)
        .replace(/&/g, '&amp;')
        .replace(/&amp;amp;/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
exports.xmlEscapeText = xmlEscapeText;
/**
 * Escape XML special markup characters: tag delimiter < > entity
 * reference start delimiter & and quotes ". The escaped string can be
 * used in double quoted XML attribute value portions (i.e. in
 * attributes within start tags).
 * @param s The string to be escaped.
 * @returns The escaped string.
 */
function xmlEscapeAttr(s) {
    return xmlEscapeText(s).replace(/"/g, '&quot;');
}
/**
 * Wrapper function to access attribute values of template element
 * nodes. Currently this calls he.decode because in some DOM
 * implementations the return value of node.getAttributeValue()
 * contains unresolved XML entities, although the DOM spec requires
 * that entity references are resolved by the DOM.
 * @param node TODO
 * @param name TODO
 * @returns TODO
 */
function xmlGetAttribute(node, name) {
    // TODO(mesch): This should not be necessary if the DOM is working
    // correctly. The DOM is responsible for resolving entities, not the
    // application.
    var value = (0, functions_1.domGetAttributeValue)(node, name);
    if (value) {
        return he_1.default.decode(value);
    }
    return value;
}
exports.xmlGetAttribute = xmlGetAttribute;
/**
 * Wrapper function to access the owner document uniformly for document
 * and other nodes: for the document node, the owner document is the
 * node itself, for all others it's the ownerDocument property.
 *
 * @param {XNode} node
 * @return {XDocument}
 */
function xmlOwnerDocument(node) {
    if (node === null || node === undefined) {
        throw new Error('Node has no valid owner document.');
    }
    if (node.nodeType === constants_1.DOM_DOCUMENT_NODE) {
        return node;
    }
    return xmlOwnerDocument(node.ownerDocument);
}
exports.xmlOwnerDocument = xmlOwnerDocument;
//# sourceMappingURL=xml-functions.js.map